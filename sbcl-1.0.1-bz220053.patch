Index: src/runtime/linux-os.c
===================================================================
RCS file: /cvsroot/sbcl/sbcl/src/runtime/linux-os.c,v
retrieving revision 1.67
diff -u -r1.67 linux-os.c
--- src/runtime/linux-os.c	15 Dec 2006 01:48:59 -0000	1.67
+++ src/runtime/linux-os.c	30 Dec 2006 16:39:49 -0000
@@ -185,7 +185,12 @@
             "LD_ASSUME_KERNEL\n");
     }
 #endif
+#ifdef LISP_FEATURE_PPC
+    /* Assume 64KiB pages on PowerPC, since that's what the ABI says */
+    os_vm_page_size = 65536;
+#else
     os_vm_page_size = getpagesize();
+#endif
 
     /* KLUDGE: Disable memory randomization on new Linux kernels
      * by setting a personality flag and re-executing. (We need
Index: src/runtime/gencgc-internal.h
===================================================================
RCS file: /cvsroot/sbcl/sbcl/src/runtime/gencgc-internal.h,v
retrieving revision 1.17
diff -u -r1.17 gencgc-internal.h
--- src/runtime/gencgc-internal.h	2 Nov 2006 17:18:37 -0000	1.17
+++ src/runtime/gencgc-internal.h	30 Dec 2006 16:39:49 -0000
@@ -29,6 +29,15 @@
 inline void *page_address(page_index_t);
 int gencgc_handle_wp_violation(void *);
 
+
+/* Note that this structure is also used from Lisp-side in
+ * src/code/room.lisp, and the Lisp-side structure layout is currently
+ * not groveled from C code but hardcoded. Any changes to the
+ * structure layout need to be also made there.
+ *
+ * FIXME: We should probably just define this structure in Lisp, and
+ * output the C version in genesis. -- JES, 2006-12-30.
+ */
 struct page {
     /* The name of this field is not well-chosen for its actual use.
      * This is the offset from the start of the page to the start
@@ -40,15 +49,11 @@
      * than the actual bytes used for pages within the current
      * allocation regions. It should be 0 for all unallocated pages (not
      * hard to achieve).
-     *
-     * Currently declared as an unsigned short to make the struct size
-     * smaller. This means that GENCGC-PAGE-SIZE is constrained to fit
-     * inside a short.
      */
+#if PAGE_BYTES > USHRT_MAX
+    unsigned int bytes_used;
+#else
     unsigned short bytes_used;
-
-#if USHRT_MAX < PAGE_BYTES
-#error "PAGE_BYTES too large"
 #endif
 
     unsigned
Index: src/runtime/coreparse.c
===================================================================
RCS file: /cvsroot/sbcl/sbcl/src/runtime/coreparse.c,v
retrieving revision 1.36
diff -u -r1.36 coreparse.c
--- src/runtime/coreparse.c	15 Dec 2006 02:57:53 -0000	1.36
+++ src/runtime/coreparse.c	30 Dec 2006 16:39:49 -0000
@@ -349,7 +349,16 @@
                 size -= bytes_read;
                 while (bytes_read) {
                     bytes_read -= sizeof(long);
-                    page_table[offset++].first_object_offset = data[i++];
+                    /* Ignore all zeroes. The size of the page table
+                     * core entry was rounded up to os_vm_page_size
+                     * during the save, and might now have more
+                     * elements than the page table.
+                     */
+                    if (data[i]) {
+                        page_table[offset].first_object_offset = data[i];
+                    }
+                    i++;
+                    offset++;
                 }
             }
 
Index: src/compiler/ppc/backend-parms.lisp
===================================================================
RCS file: /cvsroot/sbcl/sbcl/src/compiler/ppc/backend-parms.lisp,v
retrieving revision 1.3
diff -u -r1.3 backend-parms.lisp
--- src/compiler/ppc/backend-parms.lisp	19 May 2002 13:55:32 -0000	1.3
+++ src/compiler/ppc/backend-parms.lisp	30 Dec 2006 16:39:49 -0000
@@ -3,5 +3,10 @@
 (def!constant +backend-fasl-file-implementation+ :ppc)
 (setf *backend-register-save-penalty* 3)
 (setf *backend-byte-order* :big-endian)
-(setf *backend-page-size* 4096)
 
+(eval-when (:compile-toplevel :load-toplevel :execute)
+  (setf *backend-page-size* #!+linux 65536 #!-linux 4096))
+
+;;; The size in bytes of the GENCGC pages. Should be a multiple of the
+;;; architecture page size.
+(def!constant gencgc-page-size *backend-page-size*)
Index: src/compiler/ppc/parms.lisp
===================================================================
RCS file: /cvsroot/sbcl/sbcl/src/compiler/ppc/parms.lisp,v
retrieving revision 1.31
diff -u -r1.31 parms.lisp
--- src/compiler/ppc/parms.lisp	2 Nov 2006 15:35:13 -0000	1.31
+++ src/compiler/ppc/parms.lisp	30 Dec 2006 16:39:49 -0000
@@ -24,11 +24,6 @@
 ;;; object
 (def!constant n-byte-bits 8)
 
-
-;;; The size in bytes of the GENCGC pages. Should be a multiple of the
-;;; architecture code size.
-(def!constant gencgc-page-size 4096)
-
 ;;; flags for the generational garbage collector
 (def!constant pseudo-atomic-interrupted-flag 1)
 (def!constant pseudo-atomic-flag 4)
Index: src/code/linux-os.lisp
===================================================================
RCS file: /cvsroot/sbcl/sbcl/src/code/linux-os.lisp,v
retrieving revision 1.13
diff -u -r1.13 linux-os.lisp
--- src/code/linux-os.lisp	18 Jun 2006 19:11:31 -0000	1.13
+++ src/code/linux-os.lisp	30 Dec 2006 16:39:49 -0000
@@ -43,9 +43,8 @@
       (error "Unix system call getrusage failed: ~A." (strerror utime)))
     (values utime stime majflt)))
 
+(sb!alien:define-alien-variable "os_vm_page_size" sb!unix:size-t)
+
 ;;; Return the system page size.
 (defun get-page-size ()
-  ;; probably should call getpagesize()
-  ;; FIXME: Or we could just get rid of this, since the uses of it look
-  ;; disposable.
-  4096)
+  os-vm-page-size)
\ No newline at end of file
Index: src/code/room.lisp
===================================================================
RCS file: /cvsroot/sbcl/sbcl/src/code/room.lisp,v
retrieving revision 1.38
diff -u -r1.38 room.lisp
--- src/code/room.lisp	3 Nov 2006 19:54:00 -0000	1.38
+++ src/code/room.lisp	30 Dec 2006 16:39:49 -0000
@@ -207,7 +207,14 @@
   (define-alien-type (struct page)
       (struct page
               (start long)
-              (bytes-used (unsigned 16))
+              ;; On platforms with small enough GC pages, this field
+              ;; will be a short. On platforms with larger ones, it'll
+              ;; be an int.
+              (bytes-used (unsigned
+                           #.(if (typep sb!vm:gencgc-page-size
+                                        '(unsigned-byte 16))
+                                 16
+                                 32)))
               (flags (unsigned 8))
               (gen (signed 8))))
   (declaim (inline find-page-index))
Index: src/compiler/generic/genesis.lisp
===================================================================
RCS file: /cvsroot/sbcl/sbcl/src/compiler/generic/genesis.lisp,v
retrieving revision 1.127
diff -u -r1.127 genesis.lisp
--- src/compiler/generic/genesis.lisp	5 Dec 2006 15:46:15 -0000	1.127
+++ src/compiler/generic/genesis.lisp	30 Dec 2006 16:39:50 -0000
@@ -2728,22 +2728,17 @@
             (setf prev-priority priority))
           (format t "#define ~A " name)
           (format t
-                  ;; KLUDGE: As of sbcl-0.6.7.14, we're dumping two
-                  ;; different kinds of values here, (1) small codes
-                  ;; and (2) machine addresses. The small codes can be
-                  ;; dumped as bare integer values. The large machine
-                  ;; addresses might cause problems if they're large
-                  ;; and represented as (signed) C integers, so we
-                  ;; want to force them to be unsigned. We do that by
-                  ;; wrapping them in the LISPOBJ macro. (We could do
-                  ;; it with a bare "(unsigned)" cast, except that
-                  ;; this header file is used not only in C files, but
-                  ;; also in assembly files, which don't understand
-                  ;; the cast syntax. The LISPOBJ macro goes away in
-                  ;; assembly files, but that shouldn't matter because
-                  ;; we don't do arithmetic on address constants in
-                  ;; assembly files. See? It really is a kludge..) --
-                  ;; WHN 2000-10-18
+                  ;; KLUDGE: We're dumping two different kinds of
+                  ;; values here, (1) small codes and (2) machine
+                  ;; addresses. The small codes can be dumped as bare
+                  ;; integer values. The large machine addresses might
+                  ;; cause problems if they're large and represented
+                  ;; as (signed) C integers, so we want to force them
+                  ;; to be unsigned by appending an U to the
+                  ;; literal. We can't dump all the values using the
+                  ;; literal-U syntax, since the assembler doesn't
+                  ;; support that syntax and some of the small
+                  ;; constants can be used in assembler files.
                   (let (;; cutoff for treatment as a small code
                         (cutoff (expt 2 16)))
                     (cond ((minusp value)
@@ -2751,7 +2746,7 @@
                           ((< value cutoff)
                            "~D")
                           (t
-                           "LISPOBJ(~DU)")))
+                           "~DU")))
                   value)
           (format t " /* 0x~X */~@[  /* ~A */~]~%" value doc))))
     (terpri))
